================
 Scope services
================

:Author:  Jan Borsodi <jborsodi@opera.com>
:Version: 0.2
:Date:    26th Feburary 2009

Changelog
=========

=== =================================================================
0.1 Moved all doc not related to STP to this document.
0.2 Finished details on "scope" service.
=== =================================================================

EBNF
====

The following common EBNF entries are defined::

  LF             ::= 0x0A
  DIGIT          ::= "0"-"9"
  NUMBER         ::= DIGIT+
  IDENTIFIER     ::= ALPHA (ALPHA | DIGIT | "-")*
  ALPHA          ::= "a"-"z" | "A"-"Z"

Commands and Events
===================

System commands
===============

All previous system commands (starts with a `*`) will be now be organized in
a proper service called "scope". See `Service: Scope`_ for more details.

Services and multiple clients
=============================

Some services allows for multiple clients to be active while others should
only have one client active at a time.
For instance the ecmascript debugger involves getting information about new
threads and scripts and can change the current state with breakpoints and
continuing execution. If two or more clients do this it would be impossible for
them to know what state the Opera host is in and there can also be conflicting
requests for instance if both tries to act on stopped threads in different
ways.

Whenever a client enables a service the service will be able to differentiate
between them with a unique client ID. The service can keep track of which
clients are active and send back information to specific clients if it wants.
It can also deny new clients to be active if one already is active.
If a service denies a client it responds with the status 1 (Conflict).

Services
========

Service: Scope
--------------

This is a special service which is always present and always enabled. It also
deviates from the other services in that it uses a special plain-text format
for sending out events and receiving commands. This is required for sending
out and receiving messages before the clients preference of formats is known.

Commands:

  ================= =========
  Name              CommandID
  ================= =========
  Handshake         4
  Enable            5
  Disable           6
  Configure         7
  Info              8
  Quit              9
  ================= =========

Events:

  ================= =========
  Name              CommandID
  ================= =========
  OnServices        0
  OnConnect         1 # OnHello
  OnQuit            2
  OnConnectionLost  3
  ================= =========

Event: OnServices
^^^^^^^^^^^^^^^^^

CommandID: 0

STP/0: *services <service-list>

This event is the first that is sent from the host (and proxy) and contains
all the available services. It is always sent encoded as an STP/0 message.

Command: Handshake
^^^^^^^^^^^^^^^^^^

CommandID: 4

STP/0: *handshake <ver>

This command is initiated by the client to choose the STP version to use
for all communication. Once the response is received the communication can
switch to the chosen version.
This command is always encoded as an STP/0 message.

It is defined as::

  HANDSHAKE          ::= STP-VERSION

The response is defined as::

  HANDSHAKE-RESPONSE ::= STP-VERSION

Event: OnHello
^^^^^^^^^^^^^^

CommandID: 1

STP/0: Not available for STP/0

This event is sent when the client connects and provides with enough
information to determine available services and their features.

The event is defined as::

  HELLO ::= "stp-version:" SINGLE-VERSION LF
            "version:" VERSION LF
            "platform:" STRING LF
            "operating-system:" STRING LF
            "user-agent:" STRING LF
            "services:" SERVICE-LIST LF

  SERVICE-LIST   ::= ( SERVICENAME "=" MAJOR-VERSION "." MINOR-VERSION ("." PATCH-VERSION)? "," ACTIVE "," MAX_ACTIVE ";" )*
  VERSION        ::= DIGIT+ ("." DIGIT+)*
  MAJOR-VERSION  ::= DIGIT+
  MINOR-VERSION  ::= DIGIT+
  PATCH-VERSION  ::= DIGIT+
  SINGLE-VERSION ::= DIGIT+
  SERVICENAME    ::= IDENTIFIER
  ACTIVE         ::= DIGIT+
  MAX_ACTIVE     ::= DIGIT+
  IDENTIFIER     ::= ALPHA (ALPHA | NUMERIC | "-")*

The client must check the MAJOR-VERSION and MINOR-VERSION for compatility, the
PATCH-VERSION is to be ignored, if wanted it could be shown to the end-user.

The MAJOR-VERSION determines major changes (ie. compatibility breaks) while
the MINOR-VERSION determines incremental changes (ie. backwards compatible).
The client must check these two numbers to ensure it is able to communicate
properly with the service, if the MAJOR-VERSION is different from the
versions the client is compatible with or the MINOR-VERSION is less than
the required version it must disconnect.

Lets says a client supports version 1.6 and up and also version 2.0 and up,
it would do::

  if major == 1 and minor >= 6 or major == 2:
    print "We support service version %d.%d" % (major, minor)
  else:
    print "We do not support service version %d.%d" % (major, minor)

Event: OnQuit
^^^^^^^^^^^^^

CommandID: 2

STP/0: *hostquit

This event is sent by Opera to the proxy or client when Opera terminates
operation. No communication with Opera is possible once Opera has sent the
event. When the proxy receives this message it broadcasts it to all its
clients.

There is no data in this event.

Event: OnConnectionLost
^^^^^^^^^^^^^^^^^^^^^^^

CommandID: 3

STP/0: Not available for STP/0

A special event which is by the proxy (and not the host) when the connection
to the Opera host is unexpectedly lost, for instance if the Opera host crashes.

There is no data in this event.

Command: Enable
^^^^^^^^^^^^^^^

CommandID: 5

STP/0: *enable <service>

This is used to enable one service in the host. Note however that the proxy
behaves differently when STP/0 is in use, then it expects a list of services
separated by comma. The proxy will then send each service as separate *enable
call to the host.

Note: The internal "scope" service cannot be enabled since it is always enabled.

It is defined as::

  ENABLE       ::= SERVICENAME

It will enable the service and report back the result.

The response is defined as::

  ENABLE-RESPONSE ::= SERVICENAME

If the service is not found it will return with status "Service Not Found" (6).
If the service could not be enabled it will return with status
"Service Not Enabled" (8).
If the client tries to enable the "scope" service it will return with status
"Bad Request" (3).
If the client tries to enable a service before the Configure command has been
used it will return with status "Bad Request" (3).

Command: Disable
^^^^^^^^^^^^^^^^

CommandID: 6

STP/0: *disable <service>

This is used to disable a clients access to one service. If the service
has other clients connected the service will stay enabled.
Once the client has been removed the from the service it will no longer
receive events from it and will be unable to send commands to it.
The internal "scope" service cannot be disabled since it is always enabled.

It is defined as::

  DISABLE      ::= SERVICENAME

The response is a message containing the disabled service.

It is defined as::

  DISABLE-RESPONSE ::= SERVICENAME


If the service is not found it will return with status "Service Not Found" (6).
If the service is not yet enabled it will return with status
"Service Not Enabled" (8).
If the client tries to disable the "scope" service it will return with status
"Bad Request" (3).

Command: Configure
^^^^^^^^^^^^^^^^^^

CommandID: 7

STP/0: Not available for STP/0

This commands allows the client to configure their global preferences
and must be sent before any services are enabled, after they are enabled
this command cannot be used.
If the client tries to enable a service before configuring the default
format the command will fail.

The command is defined as::

  CONFIGURE    ::= "format:" FORMAT LF
  FORMAT       ::= "protocol-buffer" | "json" | "xml"

FORMAT specifies which format the client accepts in events.
For instance a client might prefer JSON structures over XML.

Note: When the STP/0 compatibility layer is in use only JSON and XML is
      allowed as default format.

The response contains no data.

If the requested format is not allowed or does not exist it will respond
with status "Bad Request" (3).

Command: Info
^^^^^^^^^^^^^

CommandID: 8

STP/0: Not available for STP/0

This is used to get information about one specific service.

It is defined as::

  INFO ::= SERVICENAME

The command list contains all the commands in the service, each command is
listed with its name and the corresponding command ID (used by STP/1).
The event list is similar to the command list but is listed for the available
events.

The response is defined as::

  INFO-RESPONSE ::= "commands:" COMMAND-LIST LF
                    "events:"   COMMAND-LIST LF
  COMMAND-LIST  ::= COMMAND ("," COMMAND)*
  COMMAND       ::= IDENTIFIER "=" NUMBER

If the service is not found it will return the message with status set
to "Service Not Found" (6).

Command: Quit
^^^^^^^^^^^^^

CommandID: 9

STP/0: *quit

The quit message is sent to Opera when the proxy or client terminates operation.
No communication with the proxy will be possible once it has sent the quit
message. When Opera receives this message it should disable all debugging
services that are currently enabled. 

There is no data in this command and it will not result in a response.

Existing clients
================

============= ===============
Name          Protocol
============= ===============
Dragonfly     HTTP/Javascript
OpWatir       HTTP
PyScope       STP
devtools-test STP
============= ===============
