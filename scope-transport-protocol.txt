=============================
 Scope transport protocol v1
=============================

:Author:  Jan Borsodi <jborsodi@opera.com>
:Version: 0.9
:Date:    3rd April 2009

Changelog
=========

=== =================================================================
0.1 Initial ideas
0.2 Protocol supports backwards compatibility with old clients.
0.3 Added overview of all protocols, formats and clients.
    Simplified protocol due to relaxed compatibility requirements.
    Changed header structure slightly.
    Added more details on HTTP and Javascript clients.
0.4 Fixed inconsistencies and mistakes in protocol and examples.
    Details on existing * commands.
0.5 Replaced `tag` in Javascript client with a callback.
    Moved version checking in Javascript client to the `connect`
    callback.
0.6 Revised and simplified several aspects after discussions.
0.7 Minor changes to status, client id and version numbers
0.8 Cleaned up document to make it match the implementation and
    added information on the handshake phase.
0.9 Moved most of the logic away from the proxies and into the host.
    Changed STP message to be defined as a proto message which allows
    for more flexibility, it also has a new prefix.
=== =================================================================

EBNF
====

The following common EBNF entries are defined::

  PB-UINT32      ::= <32bit unsigned encoded as Protocol Buffer varint>
  PB-UINT64      ::= <64bit unsigned encoded as Protocol Buffer varint>
  PB-ZERO-UINT32 ::= <0 encoded as Protocol Buffer varint>
  DIGIT          ::= "0"-"9"

Unified Message Structure
=========================

This is a new specification which describes how messages are structured in
core-2.4 and higher. It is abbreviated as UMS and will be referenced
throughout the document.

UMS is described in further details in a separate document.

Protocols
=========

There are currently several different protocols in use by scope and related
components. To avoid confusion between them and their improvements they
are summarized in the following sections.

Scope Transport Protocol
------------------------

This is the basic component in the communication layer, abbreviated as STP.
It defines how to send commands with data (arguments) between the
Opera host and the clients.

STP version 0 is defined as::

  STP          ::= COUNT TERMINATOR KEYWORD TERMINATOR DATA
  TERMINATOR   ::= " "
  COUNT        ::= "0"-"9"+
  KEYWORD      ::= COMMAND | SERVICE
  COMMAND      ::= "*" COMMAND-NAME
  COMMAND-NAME ::= "services" | "enable" | "disable" | "quit" | "hostquit"
  SERVICE      ::= ^[ ,]+

The flow of the transport protocol currently looks like this::

              Opera              proxy                 client
  
  *services     ---------------->
                                      ----------------->   *services
                                      <-----------------   *enable
  *enable       <----------------
  data          <--------------------------------------->  data
                                  ....
                                      <------------------  *quit
  *disable      <----------------
  *quit         ---------------->
                                      ------------------>  *hostquit
                                      ------------------>  *quit

STP is used between the Opera host and the proxy as well as between the proxy
and clients speaking STP.

Scope HTTP Adapter Protocol
---------------------------

This is the communication layer between the proxy and clients
which are limited to HTTP communication. The proxy takes care of transforming
the STP communication to HTTP request/responses. The major difference is how
requests and responses/events are handled. In HTTP the request/response is
synchronous and you cannot receive data without asking for it.

Currently used by Dragonfly when loaded trough the proxy
(/file/ecma-debugger/client.xml)

Scope Javascript Protocol
-------------------------

This is the direct communication layer used between
the Opera Host and the direct Javascript client. Here the STP is trimmed
down to only send the KEYWORD and DATA elements.
All of this handled by the the opera.scopeTransmit and opera.scopeAddClient
JS functions.

Currently used by the builtin Dragonfly client for the desktop 9.5 release.

Service Protocols
=================

In addition to the transport protocol there is also protocols defined by each
service which defines formats used and available commands.

EcmaScript Debugger Protocol
----------------------------

Uses XML for the ecmascript part. Also has CSS inspector which can respond in
XML and XML+JSON. Requests are all in XML.
Version: 5

Problems
========

The current protocol is based around sending Unicode strings to and from the
clients, which makes it hard to send binary data. Also the encoding is
hardcoded to UTF-16 for the entire message (STP and payload), this represents
uneccessary overhead for sending data which is often in US-ASCII only.

XML is used as primary format which is inefficient when transporting lots
of data, lightweight alternatives are needed. XML also affects the decoding
process of some clients since it has to first decode it to a DOM tree and
then extract interesting parts using the DOM interface which is slow and
cumbersome.
The format is also predeterminded by each service and there is no way
to change dynamically. For instance Javascript based clients will be
able to decode the responses more quickly if it is sent as JSON.

There is no standard way to tie (ie. a tag) a response to a previous
request, this is currently embedded in the content of the request
which is specific to each service and each command in the service. For
instance if you receive an error message there is no information about
what request caused this error, due to the error handler being outside
of the service implementation and has no knowledge of the <tag> entry.
There is also a chance of tag-conflicts when multiple clients are in use,
a better system for handling the tags is needed.

The protocol was designed to handle multiple clients with the use of
the proxy. However there are currently problems with multiple clients
in some services (e.g ecmascript-debugger). Services that cannot handle
this should deny multiple `*enable` requests and send back an error message
to the client.
  
Overview
========

The various parts of the scope communication chain are:

===================== ====================
Communication         Port/Protocol
===================== ====================
Opera<->Proxy/Client  Port:7001 STP/0
Proxy<->Clients       Port:8001 STP/0
Proxy<->HTTP-Client   Port:8002 HTTP/1.1
Opera<->Opera         Port:49152-65535 STP/0
Opera<->Remote Opera  Port:49152-65535 STP/0
Opera<->JS-Client     Javascript functions
===================== ====================

These are the following services with formats and versions.

====================== ============== ================
Service                Format         Version
====================== ============== ================
ecmascript-debugger    pure XML       4
css-inspector (of esd) XML/XML+JSON   4
====================== ============== ================

.. TODO: Fill in complete service list.

To get a better overview a few examples follows which displays how the various
protocols communicate.

A typical developer setup with Dragonfly communicating with the Proxy using
the HTTP adapter protocol::

  +-------+ STP/0 +-------+ HTTP/1.1 +-----------+
  |       | 7001  |       |   8002   |           |
  | Scope |<----->| Proxy +<-------->| Dragonfly |
  |       |       |       |          |           |
  +-------+       +-------+          +-----------+

The common usage scenario with Dragonfly connecting to Opera using
the internal javascript methods. Internally these methods will
communicate with scope using an internal socket (will be changed)::

  +-------+ +----------+            +-----------+
  |       | | Opera    | Javascript |           |
  | Scope | | Internal |<---------->| Dragonfly |
  |       | | "Proxy"  |            |           |
  +-------+ +----------+            +-----------+
     ^         ^
     |         |
     +---------+
        STP/0
     49152-65535

Another setup with Dragonfly for remote debugging on an embedded device,
in this case a mobile phone::

  +-------+ +----------+            +-----------+
  |       | | Opera    | Javascript |           |
  | Scope | | Internal |<---------->| Dragonfly |
  |       | | "Proxy"  |            |           |
  +-------+ +----------+            +-----------+
               ^
               |
               |
               | STP/0
  +---------+  | 7001
  |         |  |
  | Phone   |<-+
  | w/Scope |
  |         |
  +---------+

Other clients can communicate directly using STP, here the Python client 
is shown::

  +-------+ STP/0 +-------+  STP/0   +---------+
  |       | 7001  |       |   8001   |         |
  | Scope |<----->| Proxy +<-------->| PyScope |
  |       |       |       |          |         |
  +-------+       +-------+          +---------+

Backwards compatibility
=======================

The new protocol will introduce a major break in compatibility between the
host, proxy and clients. To ensure that future changes are less disruptive
a set of compatibility rules will be defined. The various components in scope
will be defined to either provide a break between each version change or
provide only incremental changes for each version.

The transport protocol is the fundemental part and changes to it will be hard
to do incrementally so there is only a need for breaks between versions.
This means that clients must immediately disconnect if they encounter a
version they do not know how to handle.

Services however will use a combination of incremental and breaking changes.
This is handled by supplying a version number with two components, the first
is the major version and determines changes that will break existing clients,
the second is the minor version and will determine incremental (or additional)
changes. This means that clients will not need to be updated if only the minor
version increases. For this to be possible the following rules apply:

1. Events and responses will be sent using the same structure as the previous
   versions.
2. Events and commands can only get new optional parameters, existing
   parameters cannot change or be removed.
3. If a command requires a change of behaviour (or parameter change) a new
   command must be made and the existing one must be kept.
4. The new and optional parameters to commands can be used to trigger extended
   functionality, or alternative behaviour. However this must be confined to
   the client that request the command.
5. The order of fields can never be changed.

If the amount of work to keep backwards compatibility increases or the code
gets bloated the major version must be increased. This will signal a major
change and allows for older behaviour and code to be cleanup or removed.

The compatibility changes in each service is handled separately, this ensures
that a client which is dependent on one specific service does not need to
change unless that service gets a major changes.

Finally a global version for scope is defined, this will use the current core
version. This allows clients with more complex service dependencies a way to
determine available features on a global scale.

Transport layer
---------------

The transport layer will support both the new protocol (STP/1) and the old
(STP/0). If not all nodes on the transport layer can speak the new protocol
it will fallback to STP/0 and use a special compatibility layer to ensure
that messages still can be transported correctly.

When STP/0 is in use it will still use the Unified Message Structure for the
message content, but the format will be restricted to XML and JSON.
Additionally the payload will be modified to contain the extra fields which
are unique to STP/1, when decoding the reverse is applied to make the real
payload appear as it was originally. Encoding of message will also change
to UTF-16-BE to be compatible with STP/0.

TODO: Figure out we should a common header or not.

For JSON the real payload is wrapped in a new list and looks like::

  [<command-name>, <tag>, <status>, <payload>]

For instance::

  ["get-window-list", 5, 0, [...]]

If an error occured it might look like::

  ["get-window-list", 5, 1, [...]]

For XML the extra fields are inserted into the XML. The *tag* is added as the
first sub-element, *status* is added as an attribute to the root element and
the *command-name* is used in the root element. In short the only difference
from the XML used is core-2.3 and lower is the new *status* attribute.
The new XML structure looks like::

  <[command-name] status="[status]">
    <tag>[tag]</tag>
    ...
  </[command-name]>

The tag element will only be present for requests/responses and status
attribute will only be added when there is an error.

For instance a request might look like::

  <get-window-list>
    <tag>5</tag>
    ...
  </get-window-list>

If an error occured the response would look like::

  <get-window-list-response status="1">
    <tag>5</tag>
    ...
  </get-window-list>

Opera host
----------

The host will first send out the service list using the old syntax (*services),
then it will wait for the first request from the client. If the client sends
the new handshake the version to use is determined in the handshake message,
otherwise it means and older client is connecting and the host will switch
to STP/0 and XML/JSON formatted messages.

Proxy
-----

The proxy will also support both protocol versions, the version that will
be used is determined by the client, unless the host is running core-2.3 or
lower in which case all communication is done using STP/0.

Client detection and handshake is handled in the same manner as the host.
The proxy will also ensure that only one client is allowed to connect until
the STP version is determined. After the version is set additional client
connections are allowed but they will be forced to follow the STP version
in use or disconnect.

The HTTP API as it is today will be removed from the external proxy as it
is only used for internal development of Dragonfly. A separate implementation
will be made for development purposes only.

Client
------

New clients will need to decide the version of the protocol to use. If the host
and proxy supports STP/1 then it can choose to initiate this by performing
the new handshake. If STP/1 cannot be used then the client must fallback to
STP/0 using XML or JSON only.

In addition to checking the transport protocol version it must also check the
core version of the host. If the host has core-2.4 or higher it means it
supports the new Unified Message Structure. This affects how the messages
are constructed, ie. names of fields and structure.

In short the following setups will be encountered:

1. STP/1 and UMS
2. STP/0 and UMS formatted as JSON or XML
3. STP/0 and old XML structures (core-2.3)

Newer clients that does not need to consider backwards compatibility will only
need to support case #1.

Dragonfly
---------

Dragonfly cannot control the transport protocol version that will be used
and must adhere to the message structure that will be in use. Dragonfly
will need to read out the STP and core version and decide from that how
messages are to be formatted and parsed.

When it is possible Dragonfly will stick to JSON as the format for message,
this would mean case #1 and #2 as described in the section Client_.

STP/1
=====

The new transport layer is defined as::

  CONNECTION     ::= SERVICES HANDSHAKE MESSAGES
  MESSAGES       ::= MESSAGE*

This shows that the original STP/0 service list SERVICES is the first
entry to be sent. Next after comes a handshake which results in the handshake
response `HANDSHAKE` followed by the actual transport messages.

The outer layer of the transport message is defined as::

  MESSAGE        ::= "STP" STP-VER STP-SIZE STP-DATA
  STP-VER        ::= BYTE
  STP-SIZE       ::= PB-UINT64
  STP-DATA       ::= STP-SIZE * BYTE

This allows for multiple versions of a message to be sent, each message is
uniquely identified by the string "STP" followed by a version number. The
size of the entire message is followed by the data of the message, this
allows any decoder to check the version and skip data that it does not
understand. The decoding of STP-DATA depends on the version.

An STP/1 message will then look like::

  MESSAGE        ::= "STP" \x01 STP-SIZE STP1-DATA

SERVICES
--------

The very first data that is sent by the host is a list of services.
This data is encoded in UTF-16-BE (UTF-16 Big Endian) and is the
same format as it was in STP/0, this ensures compatibility with older
clients::

  SERVICES     ::= SIZE SP "*services" SP SERVICE-LIST
  SERVICE-LIST ::= SERVICE-NAME { "," SERVICE }
  SERVICE-NAME ::= <any character except comma>
  SIZE         ::= DIGIT+

HANDSHAKE
---------

The handshake allows the client to configure the required STP version
before any messages are sent. The client must decide on the desired STP
version, chosen among the available versions in the SERVICES entry.

The client will then send an "*enable" request with the specific
stp service::

  HANDSHAKE-REQ ::= "*enable" SP "stp-" VER
  VER           ::= "1"
  HANDSHAKE     ::= "STP/1" LF

The handshake request is encoded as an STP/0 message while the response
is sent as plain US-ASCII.
For now there is only one version to enable, ie. STP/1.

Once the handshake is sent the client must swith to the specific STP
version and parse messages in the new format.

STP1-DATA
---------

For STP/1 messages STP-DATA is defined as::

  STP1-DATA      ::= STP1-TYPE HEADERS
  STP1-TYPE      ::= PB-UINT32 # 1 = command, 2 = response, 3 = event, 4 = error
  HEADERS        ::= PB-MESSAGE

STP1-TYPE represents which type of STP/1 message is found in the HEADERS
which is represented by the protocol buffer message TransportMessage.
The type tells one what fields one can expect in the HEADERS and maps to
a specific protocol buffer message.

The following types are defined:

========= =============
STP1-TYPE Proto message
========= =============
1         Command
2         Response
3         Event
4         Error
========= =============

Other types can be added in the future so any unknown type should be ignored
by clients and passed on by proxies.

HEADERS is a PB encoded message containing all the remaining fields for the
header. Any decoder must ignore fields it does not understand, proxies must
also ensure these fields are transported to the client/host.

The headers are defined using a Protocol Buffer message::

    message TransportMessage
    {
      required string service = 1;
      required uint32 commandID = 2;
      required uint32 format = 3;
      optional uint32 status = 4;
      optional uint32 tag = 5;
      optional uint32 clientID = 6;
      optional string uuid = 7;
      required bytes payload = 8;
    }

Some of the fields are optional and will be present depending on the type of
STP message, for commands the message will be::

    message Command
    {
      required string service = 1;
      required uint32 commandID = 2;
      required uint32 format = 3;
      required uint32 tag = 5;
      required bytes  payload = 8;

      // either clientID or uuid must be sent
      optional uint32 clientID = 6;
      optional string uuid = 7;
    }

For responses the message is defined as::

    message Response
    {
      required string service = 1;
      required uint32 commandID = 2;
      required uint32 format = 3;
      required uint32 tag = 5;
      required bytes  payload = 8;

      // either clientID or uuid must be sent
      optional uint32 clientID = 6;
      optional string uuid = 7;
    }

For events it looks like::

    message Event
    {
      required string service = 1;
      required uint32 commandID = 2;
      required uint32 format = 3;
      required bytes  payload = 8;

      // Events can only be sent to clients that has received a clientID value
      optional uint32 clientID = 6;
    }

For errors the message contains::

    message Error
    {
      required string service = 1;
      required uint32 commandID = 2;
      required uint32 format = 3;
      optional uint32 status = 4;
      optional uint32 tag = 5;

      // either clientID or uuid must be sent
      optional uint32 clientID = 6;
      optional string uuid = 7;
    }

service
-------

The field `service` is the name of the service on the host as reported in
the initial `\*services` message.

commandID
---------

The field `commandID` is a number in the range 0 to 2^32-1 and corresponds to a
given command in the specific service. The command value is unique in the
specific service only and is guaranteed to stay the same for all future releases.

status
------

The field `status` is used to send back information to the client when errors
occurs. This field is optional and is only sent when the STP1-TYPE is an
error message.

==== ==========================
Code Description
==== ==========================
0    OK
1    Conflict
2    Unsupported Type
3    Bad Request
4    Internal Error
5    Command Not Found
6    Service Not Found
7    Out Of Memory (OOM)
8    Service Not Enabled
9    Service Already Enabled
==== ==========================

TODO: Add more error codes as needed.

format
------

The field `format` is used to identifiy the format of the message body, this
also determines the encoding used on the message body.

=====  =====================  ========
Code   Description            Encoding
=====  =====================  ========
0      Protocol Buffer (UMS)  OCTET
1      JSON structures (UMS)  UTF-8
2      XML structures (UMS)   UTF-8
=====  =====================  ========

clientID
--------

The field `clientID` is used to represent a client using a numerical ID.
This ID will be valid for one connection and must be reattained when a new
connection is achieved. See also the `uuid` field.

This field will be filled in by the client when it sends commands to the host,
and will be present in the responses and errors.

uuid
----

The field `uuid` represents a Universal Unique ID which globally identifies a
given client. This field will only be used when the client does not yet have
a `clientID`, which means the initial connection to the host.
The client must fill in a unique string which represents the client, the host
will then use this string in any responses going to the client.

It is recommended that the client generates an MD5 or SHA1 based upon a random
value and the current date. This will then even allow running the same client
multiple times.

For instance the client could send a string like this::

  "md5:d41d8cd98f00b204e9800998ecf8427e"

tag
---

The field `tag` represent a synchronization value which is sent by the client to
bind the request to a response from the host. This field is only used when a
previous tag was sent from the client, so any events will not have this field.

The tag system will be part of the protocol API and provides a standardized
way of doing synchronization. The tag value can be read without knowledge of
the underlying format, this allows the proxy to properly filter responses back
to the correct client and it also makes it easier for the clients to handle
responses since it can map the tag value to a response handler.

TAG is an unsigned integer in the range 1 to 2^31-1 and does not interfere
with tags used by other clients. The client is free to reuse the Tag value as
long as there is no current open requests using it.

payload
-------

The body (or payload) of the message depends on the `format` field but is always
sent in the `payload` field. This means that the payload can only be decoded
once the `format` has been found, otherwise it must be treated as pure binary
data.

Message flow
============

Before the STP/1 message flow can start an initialization phase is needed.
This phase is performed between the two connecting parts, this would mean
between the host and proxy as well as proxy to any clients. This phase
is used to determine the basic capabilites of the host and choose the
STP version to use for messages across all connected nodes.

When the client connects to a host or proxy it will receive a list of services.
Some of these services are meta-services and is used to determine capabilities
such as possible STP versions. For instance the host might send back::

  *services scope,ecmascript-debugger,window-manager,stp-1,core-2-4

This reports back on the STP version available through the service "stp-1".
It also reports the core version in use, in this case core-2.4 ("core-2-4").

Following is a set of examples of the message flow between a client, proxy
and host, the following symbols are used::

  ~~~~~~~~~> Handshake
  ~ ~ ~ ~ ~> Handshake response
  ---------> Command
  - - - - -> Response
  =========> Event

The client must then initiate the handshake which also determines the STP
version to use, for instance to enable STP version 1::

              Host               client
  
  *services     =================>
                <~~~~~~~~~~~~~~~~~  *enable stp-1
  STP/1\n       ~ ~ ~ ~ ~ ~ ~ ~ ~>
                <~~~~~~~~~~~~~~~~~  scope.Connect
  scope.Connect ~ ~ ~ ~ ~ ~ ~ ~ ~>

A typical message flow between a client, proxy and host looks like this::

              Opera               proxy                 client
  
  handshake       <~~~~~~~~~~~~~~~~     ~ ~ ~ ~ ~ ~ ~ ~ ~>  handshake
                                        <-----------------  scope.Connect
  scope.Connect   <----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Connect
                                        <-----------------  scope.Enable
  scope.Enable    <----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Enable

  messages        <-------------------  - - - - - - - - ->  messages
  events          =======================================>
                                    ....
                                        <-----------------  scope.Disconnect
  scope.Disconnect<----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Disconnect

If the client disconnects the socket without telling the host/proxy then
proxy will disconnect all clients on the given socket connection, for instance::

  scope.Disconnect <----------------  scope.Disconnect
                   - - - - - - - - >

An STP/0 client will initiate the message flow as described in
`Scope Transport Protocol`_.

Meta services
-------------

Meta services are sent along the regular service list to report back version
numbers and other useful information to the clients, this can then be used
to determine the capabilities of the transport layer and host itself.
All meta services consists of a prefix followed by one or more values, this
means that matching of meta services must be done on the prefix only.

The following meta services are defined:

STP versions is determined by the "stp-" meta service. The host will send
meta-service per version it supports, this means that the client must choose
among the reported versions and use that. If there is only one STP version
sent then it means that another client has already decided which version to
use, the new client must then either start using the selected version or
disconnect if it does not support it.

The service is defined as::

  META-STP ::= "stp-" NUMBER
  NUMBER   ::= DIGIT+

In addition the host will also report the STP/0 version using a special suffix
to specify the format for the compatibility messages. The host will report::

  stp-0-json,stp-0-xml

`stp-0-json` means that the body is formatted using JSON but the entire message
is sent over STP/0 using the compatibility layer. `stp-0-xml` is the same but
the format is XML.

Core version is determined by the "core-" meta service and contains the
core version after the prefix. This core version can be used to determine
the structure of the messages and how the services will act.
It is defined as::

  META-CORE    ::= "core-" DASH-VERSION
  DASH-VERSION ::= DIGIT+ ("-" DIGIT+)*
