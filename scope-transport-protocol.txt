=============================
 Scope transport protocol v1
=============================

:Author:  Jan Borsodi <jborsodi@opera.com>
:Version: 0.8
:Date:    11th February 2009

Changelog
=========

=== =================================================================
0.1 Initial ideas
0.2 Protocol supports backwards compatibility with old clients.
0.3 Added overview of all protocols, formats and clients.
    Simplified protocol due to relaxed compatibility requirements.
    Changed header structure slightly.
    Added more details on HTTP and Javascript clients.
0.4 Fixed inconsistencies and mistakes in protocol and examples.
    Details on existing * commands.
0.5 Replaced `tag` in Javascript client with a callback.
    Moved version checking in Javascript client to the `connect`
    callback.
0.6 Revised and simplified several aspects after discussions.
0.7 Minor changes to status, client id and version numbers
0.8 Cleaned up document to make it match the implementation and
    added information on the handshake phase.
=== =================================================================

EBNF
====

The following common EBNF entries are defined::

  PB-UINT32      ::= <32bit unsigned encoded as Protocol Buffer varint>
  PB-ZERO-UINT32 ::= <0 encoded as Protocol Buffer varint>
  DIGIT          ::= "0"-"9"

Unified Message Structure
=========================

This is a new specification which describes how messages are structured in
core-2.4 and higher. It is abbreviated as UMS and will be referenced
throughout the document.

UMS is described in further details in a separate document.

Protocols
=========

There are currently several different protocols in use by scope and related
components. To avoid confusion between them and their improvements they
are summarized in the following sections.

Scope Transport Protocol
------------------------

This is the basic component in the communication layer, abbreviated as STP.
It defines how to send commands with data (arguments) between the
Opera host and the clients.

STP version 0 is defined as::

  STP          ::= COUNT TERMINATOR KEYWORD TERMINATOR DATA
  TERMINATOR   ::= " "
  COUNT        ::= "0"-"9"+
  KEYWORD      ::= COMMAND | SERVICE
  COMMAND      ::= "*" COMMAND-NAME
  COMMAND-NAME ::= "services" | "enable" | "disable" | "quit" | "hostquit"
  SERVICE      ::= ^[ ,]+

The flow of the transport protocol currently looks like this::

              Opera              proxy                 client
  
  *services     ---------------->
                                      ----------------->   *services
                                      <-----------------   *enable
  *enable       <----------------
  data          <--------------------------------------->  data
                                  ....
                                      <------------------  *quit
  *disable      <----------------
  *quit         ---------------->
                                      ------------------>  *hostquit
                                      ------------------>  *quit

STP is used between the Opera host and the proxy as well as between the proxy
and clients speaking STP.

Scope HTTP Adapter Protocol
---------------------------

This is the communication layer between the proxy and clients
which are limited to HTTP communication. The proxy takes care of transforming
the STP communication to HTTP request/responses. The major difference is how
requests and responses/events are handled. In HTTP the request/response is
synchronous and you cannot receive data without asking for it.

Currently used by Dragonfly when loaded trough the proxy
(/file/ecma-debugger/client.xml)

Scope Javascript Protocol
-------------------------

This is the direct communication layer used between
the Opera Host and the direct Javascript client. Here the STP is trimmed
down to only send the KEYWORD and DATA elements.
All of this handled by the the opera.scopeTransmit and opera.scopeAddClient
JS functions.

Currently used by the builtin Dragonfly client for the desktop 9.5 release.

Service Protocols
=================

In addition to the transport protocol there is also protocols defined by each
service which defines formats used and available commands.

EcmaScript Debugger Protocol
----------------------------

Uses XML for the ecmascript part. Also has CSS inspector which can respond in
XML and XML+JSON. Requests are all in XML.
Version: 5

Problems
========

The current protocol is based around sending Unicode strings to and from the
clients, which makes it hard to send binary data. Also the encoding is
hardcoded to UTF-16 for the entire message (STP and payload), this represents
uneccessary overhead for sending data which is often in US-ASCII only.

XML is used as primary format which is inefficient when transporting lots
of data, lightweight alternatives are needed. XML also affects the decoding
process of some clients since it has to first decode it to a DOM tree and
then extract interesting parts using the DOM interface which is slow and
cumbersome.
The format is also predeterminded by each service and there is no way
to change dynamically. For instance Javascript based clients will be
able to decode the responses more quickly if it is sent as JSON.

There is no standard way to tie (ie. a tag) a response to a previous
request, this is currently embedded in the content of the request
which is specific to each service and each command in the service. For
instance if you receive an error message there is no information about
what request caused this error, due to the error handler being outside
of the service implementation and has no knowledge of the <tag> entry.
There is also a chance of tag-conflicts when multiple clients are in use,
a better system for handling the tags is needed.

The protocol was designed to handle multiple clients with the use of
the proxy. However there are currently problems with multiple clients
in some services (e.g ecmascript-debugger). Services that cannot handle
this should deny multiple `*enable` requests and send back an error message
to the client.
  
Overview
========

The various parts of the scope communication chain are:

===================== ====================
Communication         Port/Protocol
===================== ====================
Opera<->Proxy/Client  Port:7001 STP/0
Proxy<->Clients       Port:8001 STP/0
Proxy<->HTTP-Client   Port:8002 HTTP/1.1
Opera<->Opera         Port:49152-65535 STP/0
Opera<->Remote Opera  Port:49152-65535 STP/0
Opera<->JS-Client     Javascript functions
===================== ====================

These are the following services with formats and versions.

====================== ============== ================
Service                Format         Version
====================== ============== ================
ecmascript-debugger    pure XML       4
css-inspector (of esd) XML/XML+JSON   4
====================== ============== ================

.. TODO: Fill in complete service list.

To get a better overview a few examples follows which displays how the various
protocols communicate.

A typical developer setup with Dragonfly communicating with the Proxy using
the HTTP adapter protocol::

  +-------+ STP/0 +-------+ HTTP/1.1 +-----------+
  |       | 7001  |       |   8002   |           |
  | Scope |<----->| Proxy +<-------->| Dragonfly |
  |       |       |       |          |           |
  +-------+       +-------+          +-----------+

The common usage scenario with Dragonfly connecting to Opera using
the internal javascript methods. Internally these methods will
communicate with scope using an internal socket (will be changed)::

  +-------+ +----------+            +-----------+
  |       | | Opera    | Javascript |           |
  | Scope | | Internal |<---------->| Dragonfly |
  |       | | "Proxy"  |            |           |
  +-------+ +----------+            +-----------+
     ^         ^
     |         |
     +---------+
        STP/0
     49152-65535

Another setup with Dragonfly for remote debugging on an embedded device,
in this case a mobile phone::

  +-------+ +----------+            +-----------+
  |       | | Opera    | Javascript |           |
  | Scope | | Internal |<---------->| Dragonfly |
  |       | | "Proxy"  |            |           |
  +-------+ +----------+            +-----------+
               ^
               |
               |
               | STP/0
  +---------+  | 7001
  |         |  |
  | Phone   |<-+
  | w/Scope |
  |         |
  +---------+

Other clients can communicate directly using STP, here the Python client 
is shown::

  +-------+ STP/0 +-------+  STP/0   +---------+
  |       | 7001  |       |   8001   |         |
  | Scope |<----->| Proxy +<-------->| PyScope |
  |       |       |       |          |         |
  +-------+       +-------+          +---------+

Backwards compatibility
=======================

The new protocol will introduce a major break in compatibility between the
host, proxy and clients. To ensure that future changes are less disruptive
a set of compatibility rules will be defined. The various components in scope
will be defined to either provide a break between each version change or
provide only incremental changes for each version.

The transport protocol is the fundemental part and changes to it will be hard
to do incrementally so there is only a need for breaks between versions.
This means that clients must immediately disconnect if they encounter a
version they do not know how to handle.

Services however will use a combination of incremental and breaking changes.
This is handled by supplying a version number with two components, the first
is the major version and determines changes that will break existing clients,
the second is the minor version and will determine incremental (or additional)
changes. This means that clients will not need to be updated if only the minor
version increases. For this to be possible the following rules apply:

1. Events and responses will be sent using the same structure as the previous
   versions.
2. Events and commands can only get new optional parameters, existing
   parameters cannot change or be removed.
3. If a command requires a change of behaviour (or parameter change) a new
   command must be made and the existing one must be kept.
4. The new and optional parameters to commands can be used to trigger extended
   functionality, or alternative behaviour. However this must be confined to
   the client that request the command.
5. The order of fields can never be changed.

If the amount of work to keep backwards compatibility increases or the code
gets bloated the major version must be increased. This will signal a major
change and allows for older behaviour and code to be cleanup or removed.

The compatibility changes in each service is handled separately, this ensures
that a client which is dependent on one specific service does not need to
change unless that service gets a major changes.

Finally a global version for scope is defined, this will use the current core
version. This allows clients with more complex service dependencies a way to
determine available features on a global scale.

Transport layer
---------------

The transport layer will support both the new protocol (STP/1) and the old
(STP/0). If not all nodes on the transport layer can speak the new protocol
it will fallback to STP/0 and use a special compatibility layer to ensure
that messages still can be transported correctly.

When STP/0 is in use it will still use the Unified Message Structure for the
message content, but the format will be restricted to XML and JSON.
Additionally the payload will be modified to contain the extra fields which
are unique to STP/1, when decoding the reverse is applied to make the real
payload appear as it was originally. Encoding of message will also change
to UTF-16-BE to be compatible with STP/0.

For JSON the real payload is wrapped in a new list and looks like::

  [<command-name>, <tag>, <status>, <payload>]

For instance::

  ["get-window-list", 5, 0, [...]]

If an error occured it might look like::

  ["get-window-list", 5, 1, [...]]

For XML the extra fields are inserted into the XML. The *tag* is added as the
first sub-element, *status* is added as an attribute to the root element and
the *command-name* is used in the root element. In short the only difference
from the XML used is core-2.3 and lower is the new *status* attribute.
The new XML structure looks like::

  <[command-name] status="[status]">
    <tag>[tag]</tag>
    ...
  </[command-name]>

The tag element will only be present for requests/responses and status
attribute will only be added when there is an error.

For instance a request might look like::

  <get-window-list>
    <tag>5</tag>
    ...
  </get-window-list>

If an error occured the response would look like::

  <get-window-list-response status="1">
    <tag>5</tag>
    ...
  </get-window-list>

Opera host
----------

The host will first send out the service list using the old syntax (*services),
then it will wait for the first request from the client. If the client sends
the new handshake the version to use is determined in the handshake message,
otherwise it means and older client is connecting and the host will switch
to STP/0 and XML/JSON formatted messages.

Proxy
-----

The proxy will also support both protocol versions, the version that will
be used is determined by the client, unless the host is running core-2.3 or
lower in which case all communication is done using STP/0.
To ensure that old proxies are detected the proxy will also report the proxy
version number to any connecting clients using a meta service. The version
number of the new proxy will be "2.0".

Client detection and handshake is handled in the same manner as the host.
The proxy will also ensure that once the STP version is determined it will
not allow clients that tries to communicate in a different version.

The HTTP API as it is today will be removed from the external proxy.
A new API will be made using a totally separate implementation, a spec
will be made to describe the new API.

Client
------

New clients will need to decide the version of the protocol to use. If the host
and proxy supports STP/1 then it can choose to initiate this by performing
the new handshake. If STP/1 cannot be used then the client must fallback to
STP/0 using XML or JSON only.

In addition to checking the transport protocol version it must also check the
core version of the host. If the host has core-2.4 or higher it means it
supports the new Unified Message Structure. This affects how the messages
are constructed, ie. names of fields and structure.

In short the following setups will be encountered:

1. STP/1 and UMS
2. STP/0 and UMS formatted as JSON or XML
3. STP/0 and old XML structures (core-2.3)

Newer clients that does not need to consider backwards compatibility will only
need to support case #1.

Dragonfly
---------

Dragonfly cannot control the transport protocol version that will be used
and must adhere to the message structure that will be in use. Dragonfly
will need to read out the STP and core version and decide from that how
messages are to be formatted and parsed.

When it is possible Dragonfly will stick to JSON as the format for message,
this would mean case #1 and #2 as described in the section Client_.

STP/1
=====

The new transport message is defined as::

  CONNECTION     ::= SERVICES HANDSHAKE MESSAGES
  MESSAGES       ::= MESSAGE*
  MESSAGE        ::= MESSAGE-HEADER MESSAGE-BODY
  MESSAGE-HEADER ::= SERVICE
                     COMMAND
                     TYPE-FIELD
                     CID-FIELD
                     TAG
  # The uint32 is the index value of the services list
  # Service index #0 is reserved for the internal "scope" service.
  SERVICE        ::= PB-UINT32
  # The uint32 is the value of the command (in the given service).
  COMMAND        ::= PB-UINT32
  TYPE-FIELD     ::= PB-UINT32
  CID-FIELD      ::= PB-UINT32
  TAG            ::= PB-UINT32
  MESSAGE-BODY   ::= CHUNKED-BODY

Each message is encoded using Protocol Buffer binary encoding.
The result is that the overhead of each message overhead is
kept to a minimum, the smallest overhead is 5 bytes (excludes
chunked data overhead) and the largest is 21 bytes (excludes
chunked data overhead). The average will be most likely be
around 5 to 12 bytes.

SERVICES
--------

The very first data that is sent by the host is a list of services.
This data is encoded in UTF-16-BE (UTF-16 Big Endian) and is the
same format as it was in STP/0, this ensures compatibility with older
clients::

  SERVICES     ::= SIZE SP "*services" SP SERVICE-LIST
  SERVICE-LIST ::= SERVICE-NAME { "," SERVICE }
  SERVICE-NAME ::= <any character except comma>
  SIZE         ::= DIGIT+


HANDSHAKE
---------

The handshake allows the client to configure the required STP version
before any messages are sent. The client must decide on the desired STP
version, chosen among the available versions in the SERVICES entry.

The client will then send an "*enable" request with the specific
stp service::

  HANDSHAKE-REQ ::= "*enable" SP "stp-" VER
  VER           ::= "1"
  HANDSHAKE     ::= "STP/1" LF

The handshake request is encoded as an STP/0 message while the response
is sent as plain US-ASCII.
For now there is only one version to enable, ie. STP/1.

Once the handshake is sent the client must swith to the specific STP
version and parse messages in the new format.

SERVICE
-------

SERVICE is sent as a number in the range 0 to 2^32-1 and represents the index
of the service in the initial "hello" message. The value 0 is reserved for the
internal "scope" service, this means you can communicate with this service even
if you don't have the full list.

COMMAND
-------

COMMAND value is a number in the range 0 to 2^32-1 and corresponds to a given
command in the specific service. The command value is unique in the specific
service only and is guaranteed to stay the same for all future releases.

TYPE-FIELD
----------

TYPE-FIELD is a bitfield consisting of the type and status::

  TYPE-FIELD
  {
    STATUS   uint32 : 5;
    TYPE     uint32 : 2; # 2 bits for TYPE_
  }

This ensures it is not longer than 7 bits and can be
encoded as 1 byte with varint.

STATUS
------

The STATUS value is used to send back information to the client when errors
occurs. The default of 0 means that there was no problems, and is also the
same value sent by the clients to the host.

==== ==========================
Code Description
==== ==========================
0    OK
1    Conflict
2    Unsupported Type
3    Bad Request
4    Internal Error
5    Command Not Found
6    Service Not Found
7    Out Of Memory (OOM)
8    Service Not Enabled
9    Service Already Enabled
==== ==========================

TYPE
----

The TYPE value is used to identifiy the format of the message
body, this also determines the encoding used on the message
body.

=====  =====================  ========
Code   Description            Encoding
=====  =====================  ========
0      Protocol Buffer (UMS)  OCTET
1      JSON structures (UMS)  UTF-8
2      XML structures (UMS)   UTF-8
3      Internal "scope"       UTF-8
=====  =====================  ========

CID-FIELD
---------

CID-FIELD is a bitfield (32 bit) containing the client IDs (CID) which
will receive the message. Each bit represents a client and the ones which
are to receive the message will have the bit set to 1. If there are no client
bits set, in other words the entire field is 0, then the message is sent to
all clients. In practice the bitfield will have multiple bits set only for
events which are to be sent to multiple clients, for responses to a previous
request only the bit for the corresponding client will be present.

On the host side the bitfield is used as one unique client ID (CID), if more
bits are set it will deny the request. The CID ensures there are no crashes
with tag values between multiple clients accessing the same service. This
means that the same TAG_ can be used by two clients connected to the same
service as long as both have a different CID.
This header is not needed when connecting to the Opera host directly since
only one client is possible. However when connecting to the proxy, it will
take care of assigning a unique ID to each client connection and add the CID
header to all requests going to the Opera host. If the Opera host receives a
request with a given CID it will respond with the same value.
Events and responses going from the host to the proxy will be forwarded the
corresponding clients according to the bitfield, the bitfield will not be
modified.

For instance if a bitfield with the value %110 is received the proxy will
transmit the message to client 2 (%010) and client 3 (%100), both will
receive %110 in the bitfield.

In practice any client connecting to the proxy does not have to care about the
CID, it can be read from the first message it receives from the proxy but it
serves no specific purpose other than for debugging.

TAG
---

TAG represent a synchronization value which is sent by the client to bind the
request to a response from the host. A value of 0 means there is no
synchronization involved and is used for events.

The tag system will be part of the protocol API and provides a standardized
way of doing synchronization. The tag value can be read without knowledge of
the underlying format, this allows the proxy to properly filter responses back
to the correct client and it also makes it easier for the clients to handle
responses since it can map the tag value to a response handler.

TAG is an unsigned integer in the range 1 to 2^31-1 and does not interfere
with tags used by other clients. The client is free to reuse the Tag value as
long as there is no current open requests using it.

Tag values are only needed for requests/responses, if a service sends out an
event the Tag header is set to 0.

CHUNKED-BODY
------------

Identifying the length/end of the message will no longer be done using
a Count value at the beginning. Instead the message body will be sent using
chunked encoding, that means sending over multiple chunks where each chunk
is preceded by a chunk size.

Chunked encoding will only be used for the message body.

The structure is::

  CHUNKED-BODY ::= CHUNK* LAST-CHUNK
  CHUNK        ::= CHUNK-SIZE CHUNK-DATA
  LAST-CHUNK   ::= PB-ZERO-UINT32
  CHUNK-SIZE   ::= PB-UINT32
  CHUNK-DATA   ::= CHUNK-SIZE(OCTET)

Message flow
============

Before the STP/1 message flow can start an initialization phase is needed.
This phase is performed between the two connecting parts, this would mean
between the host and proxy as well as proxy to any clients. This phase
is used to determine the basic capabilites of the host and choose the
STP version to use for messages across all connected nodes.

When the client connects to a host or proxy it will receive a list of services.
Some of these services are meta-services and is used to determine capabilities
such as possible STP versions. For instance the host might send back::

  *services scope,ecmascript-debugger,window-manager,m-stp-1,core-2.4

This reports back on the STP version available through the service "m-stp-1".
It also reports the core version in use, in this case core-2.4 ("core-2.4").

Following is a set of examples of the message flow between a client, proxy
and host, the following symbols are used::

  ~~~~~~~~~> Handshake
  ~ ~ ~ ~ ~> Handshake response
  ---------> Command
  - - - - -> Response
  =========> Event

The client must then initiate the handshake which also determines the STP
version to use, for instance to enable STP version 1::

              Host               client
  
  *services     =================>
                <~~~~~~~~~~~~~~~~~  *enable stp-1
  STP/1\n       ~ ~ ~ ~ ~ ~ ~ ~ ~>

A typical message flow between a client, proxy and host looks like this::

              Opera               proxy                 client
  
  handshake       <~~~~~~~~~~~~~~~~     ~ ~ ~ ~ ~ ~ ~ ~ ~>  handshake
  scope.OnConnect ================>
                                        =================>  scope.OnConnect
                                        <-----------------  scope.Configure
  scope.Configure <----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Configure
                                        <-----------------  scope.Enable
  scope.Enable    <----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Enable

  messages        <-------------------  - - - - - - - - ->  messages
  events          =======================================>
                                    ....
                                        <-----------------  scope.Quit
  scope.Disable   <----------------
                  - - - - - - - - >
                                        - - - - - - - - ->  scope.Disable
  scope.Quit      <----------------
  scope.OnQuit    ================>
                                        =================>  scope.OnQuit

An STP/0 client will initiate the message flow as described in
`Scope Transport Protocol`_.

Meta services
-------------

Meta services are sent along the regular service list to report back version
numbers and other useful information to the clients, this can then be used
to determine the capabilities of the transport layer and host itself.
All meta services consists of a prefix followed by one or more values, this
means that matching of meta services must be done on the prefix only.

The following meta services are defined:

STP versions is determined by the "stp-" meta service and contains a
semi-colon delimited list of available versions of the transport protocol for
the client to choose from. The client must choose one of them and send the
information in the handshake, if another client to an existing connection the
version list will be reduced to one value which is the current STP version in
use. It is defined as::

  META-STP ::= "stp-" NUMBER { ";" NUMBER }
  NUMBER   ::= DIGIT+

Core version is determined by the "core-" meta service and contains the
core version after the prefix. This core version can be used to determine
the structure of the messages and how the services will act.
It is defined as::

  META-CORE    ::= "core-" DASH-VERSION
  DASH-VERSION ::= DIGIT+ ("-" DIGIT+)*

Proxy version is determined by the "proxy-" meta service and contains the
proxy version after the prefix. This can be used to determine the capabilities
of the proxy and whether it understand STP/1 or not.
It is defined as::

  META-PROXY ::= "proxy-" VERSION
  VERSION   ::= DIGIT+ ("." DIGIT+)*
